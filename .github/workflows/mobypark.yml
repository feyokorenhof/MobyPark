name: MobyPark CI/CD

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: mobypark-selfhosted
  cancel-in-progress: false

jobs:
  test:
    name: Tests
    runs-on: self-hosted
    environment: Testing
    env:
      PROJECT: mobypark_ci_${{ github.run_id }}

    steps:
      - uses: actions/checkout@v5

      - name: Create .env for CI (workspace)
        run: |
          cat > .env << 'EOF'
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_TEST_DB=${{ secrets.POSTGRES_TEST_DB }}

          APP_HOST=0.0.0.0
          APP_PORT=8000
          APP_WORKERS=1

          DATABASE_HOST=db
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          DATABASE_URL=postgresql+asyncpg://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_DB }}
          DATABASE_URL_TEST=postgresql+asyncpg://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_TEST_DB }}

          SYNC_DATABASE_URL=postgresql+psycopg://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_DB }}
          SYNC_DATABASE_URL_TEST=postgresql+psycopg://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@db:5432/${{ secrets.POSTGRES_TEST_DB }}
          EOF
      - name: Define compose args
        run: |
          echo "COMPOSE_ARGS=-p $PROJECT --env-file .env -f docker-compose.yml -f docker-compose-ci.yml" >> $GITHUB_ENV
      - name: Pre-clean compose project (idempotent)
        run: |
          set -eux
          docker compose $COMPOSE_ARGS down -v --remove-orphans || true
      - name: Build and start services
        run: |
          docker compose $COMPOSE_ARGS up -d --build --remove-orphans

      - name: Debug db container state
        if: always()
        run: |
          docker compose $COMPOSE_ARGS ps
          docker compose $COMPOSE_ARGS logs --no-color --tail=200 db || true

      - name: Wait for Postgres to accept connections
        shell: bash
        run: |
          set -euo pipefail

          DB_CID="$(docker compose $COMPOSE_ARGS ps -q db)"
          echo "DB_CID=$DB_CID"

          echo "Waiting for container health..."
          for i in {1..60}; do
            status="$(docker inspect -f '{{.State.Health.Status}}' "$DB_CID" 2>/dev/null || echo starting)"
            echo "Health: $status ($i/60)"
            [ "$status" = "healthy" ] && break
            sleep 2
          done

          status="$(docker inspect -f '{{.State.Health.Status}}' "$DB_CID" 2>/dev/null || echo unknown)"
          if [ "$status" != "healthy" ]; then
            echo "ERROR: DB never became healthy (status=$status)"
            docker logs "$DB_CID" --tail 200 || true
            exit 1
          fi

          echo "Health is healthy; verifying real connections..."
          for i in {1..60}; do
            if docker compose $COMPOSE_ARGS exec -T db bash -lc "pg_isready -h 127.0.0.1 -p 5432 -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\""; then
              echo "pg_isready OK"
              break
            fi
            echo "pg_isready not ready yet ($i/60)"
            sleep 1
          done

          # Final hard check: run an actual query
          docker compose $COMPOSE_ARGS exec -T db bash -lc \
            "psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\" -c 'SELECT 1;'"

      - name: Ensure test database exists
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_TEST_DB: ${{ secrets.POSTGRES_TEST_DB }}
        run: |
          set -e
          DB_CID=$(docker compose $COMPOSE_ARGS ps -q db)

          docker compose $COMPOSE_ARGS exec "$DB_CID" psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 \
            -c "CREATE DATABASE \"${POSTGRES_TEST_DB}\";" \
          || echo "Test DB already exists (continuing)"


      - name: Verify services are running
        shell: bash
        run: |
          set -euo pipefail
          docker compose $COMPOSE_ARGS ps
          docker compose $COMPOSE_ARGS ps --status running
      - name: Dump compose logs on failure
        if: failure()
        shell: bash
        run: |
          docker compose $COMPOSE_ARGS ps || true
          docker compose $COMPOSE_ARGS logs --no-color --tail=300 || true
      - name: Run tests
        run: |
          docker compose $COMPOSE_ARGS exec -T api pytest

      - name: Cleanup
        if: always()
        run: |
          docker compose $COMPOSE_ARGS down -v --remove-orphans

  deploy:
    name: Deploy (push to main only)
    needs: test
    runs-on: self-hosted
    environment: Production
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Deploy over SSH
        env:
          SSH_HOST: ${{ secrets.PROD_HOST }}
          SSH_USER: ${{ secrets.PROD_USER }}
          SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
        run: |
          set -euo pipefail

          install -m 700 -d ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

          ssh -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" 'bash -s' <<'EOF'
            set -euo pipefail

            cd /opt/mobypark
            git fetch origin main
            git reset --hard origin/main

            docker compose up -d --build

            # Wait until Postgres is actually accepting connections
            echo "Waiting for Postgres to accept connections..."
            for i in {1..60}; do
              if docker compose exec -T db sh -lc 'pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB"' >/dev/null 2>&1; then
                echo "Postgres is ready"
                break
              fi
              echo "Postgres not ready yet ($i/60)..."
              sleep 1
              if [ "$i" -eq 60 ]; then
                echo "Postgres did not become ready in time"
                docker compose logs db --tail=200
                exit 1
              fi
            done

            docker compose exec -T api alembic upgrade head

            curl -fsS http://127.0.0.1:8000/health >/dev/null
            echo "Deploy OK"
          EOF
